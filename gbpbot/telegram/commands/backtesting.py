"""
Module de commandes de backtesting pour le bot Telegram
====================================================

Ce module impl√©mente les commandes pour ex√©cuter et g√©rer les backtests
via l'interface Telegram du GBPBot.
"""

import asyncio
import logging
from typing import Dict, List, Any, Optional, Tuple, Union
import traceback
from datetime import datetime, timedelta
import json

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes, CallbackContext, CommandHandler, CallbackQueryHandler

# Logger
logger = logging.getLogger("gbpbot.telegram.commands.backtesting")

# Importation conditionnelle des modules de backtesting
try:
    from gbpbot.backtesting.engine import BacktestingEngine
    from gbpbot.backtesting.data_loader import DataLoader
    from gbpbot.backtesting.performance_analyzer import PerformanceAnalyzer
    BACKTESTING_AVAILABLE = True
except ImportError:
    BACKTESTING_AVAILABLE = False
    logger.warning("Module de backtesting non disponible")

# Commande /run_backtest - Lance un backtest
async def run_backtest_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Lance un backtest avec les param√®tres sp√©cifi√©s.
    Usage: /run_backtest <strat√©gie> [options]
    Options:
    --start=YYYY-MM-DD  Date de d√©but
    --end=YYYY-MM-DD    Date de fin (d√©faut: aujourd'hui)
    --chain=solana      Blockchain √† utiliser
    --capital=1000      Capital initial en USD
    --detailed          Analyse d√©taill√©e des r√©sultats
    """
    user = update.effective_user
    chat_id = update.effective_chat.id
    
    # V√©rifier l'autorisation
    if hasattr(context.bot_data.get('bot'), '_is_user_authorized'):
        if not context.bot_data.get('bot')._is_user_authorized(user.id):
            await update.message.reply_text("‚õî Vous n'√™tes pas autoris√© √† utiliser cette commande.")
            return
    
    # V√©rifier si le module de backtesting est disponible
    if not BACKTESTING_AVAILABLE:
        await update.message.reply_text(
            "‚ùå <b>Module de backtesting non disponible</b>\n\n"
            "Cette fonctionnalit√© n√©cessite l'installation du module de backtesting.",
            parse_mode="HTML"
        )
        return
    
    # Si pas de param√®tres, afficher l'aide et les strat√©gies disponibles
    if not context.args or len(context.args) < 1:
        keyboard = [
            [InlineKeyboardButton("üéØ Sniping Token", callback_data="backtest_sniper")],
            [InlineKeyboardButton("‚öñÔ∏è Arbitrage", callback_data="backtest_arbitrage")],
            [InlineKeyboardButton("üí∞ Prise de Profit", callback_data="backtest_profit_taker")],
            [InlineKeyboardButton("ü§ñ Mode Automatique", callback_data="backtest_auto")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "üîÑ <b>Backtesting de Strat√©gie</b>\n\n"
            "Choisissez la strat√©gie √† tester ou utilisez la commande avec des param√®tres:\n\n"
            "<code>/run_backtest &lt;strat√©gie&gt; [options]</code>\n\n"
            "Options disponibles:\n"
            "‚Ä¢ <code>--start=YYYY-MM-DD</code> Date de d√©but\n"
            "‚Ä¢ <code>--end=YYYY-MM-DD</code> Date de fin\n"
            "‚Ä¢ <code>--chain=solana</code> Blockchain\n"
            "‚Ä¢ <code>--capital=1000</code> Capital initial\n"
            "‚Ä¢ <code>--detailed</code> Analyse d√©taill√©e\n\n"
            "Exemple:\n"
            "<code>/run_backtest sniper --start=2024-01-01 --chain=solana --capital=1000</code>",
            parse_mode="HTML",
            reply_markup=reply_markup
        )
        return
    
    # Extraire la strat√©gie et les options
    strategy = context.args[0].lower()
    options = {
        "start_date": (datetime.now() - timedelta(days=30)).strftime("%Y-%m-%d"),
        "end_date": datetime.now().strftime("%Y-%m-%d"),
        "chain": "solana",
        "capital": 1000.0,
        "detailed": False
    }
    
    # Parser les options
    if len(context.args) > 1:
        for arg in context.args[1:]:
            if arg.startswith("--start="):
                options["start_date"] = arg.split("=")[1]
            elif arg.startswith("--end="):
                options["end_date"] = arg.split("=")[1]
            elif arg.startswith("--chain="):
                options["chain"] = arg.split("=")[1].lower()
            elif arg.startswith("--capital="):
                try:
                    options["capital"] = float(arg.split("=")[1])
                except ValueError:
                    await update.message.reply_text(
                        "‚ùå <b>Erreur de param√®tre</b>\n\n"
                        "Le capital doit √™tre un nombre valide.",
                        parse_mode="HTML"
                    )
                    return
            elif arg == "--detailed":
                options["detailed"] = True
    
    # Message de processing
    processing_message = await update.message.reply_text(
        f"üîÑ <b>Lancement du backtest...</b>\n\n"
        f"Strat√©gie: {strategy}\n"
        f"P√©riode: {options['start_date']} ‚Üí {options['end_date']}\n"
        f"Blockchain: {options['chain'].title()}\n"
        f"Capital: {options['capital']} USD\n\n"
        "Veuillez patienter pendant l'ex√©cution du backtest...",
        parse_mode="HTML"
    )
    
    try:
        # Cr√©er le moteur de backtesting
        engine = BacktestingEngine(context.bot_data.get('bot_state', {}))
        
        # Charger les donn√©es historiques
        data_loader = DataLoader()
        historical_data = await data_loader.load_data(
            chain=options["chain"],
            start_date=options["start_date"],
            end_date=options["end_date"]
        )
        
        # Ex√©cuter le backtest
        result = await engine.run_backtest(
            strategy=strategy,
            data=historical_data,
            initial_capital=options["capital"],
            detailed=options["detailed"]
        )
        
        # Analyser les performances
        analyzer = PerformanceAnalyzer()
        performance = await analyzer.analyze_results(result)
        
        # Formater la r√©ponse
        if result and performance:
            # Calculer les m√©triques principales
            total_return = performance["total_return"]
            total_trades = performance["total_trades"]
            win_rate = performance["win_rate"]
            profit_factor = performance.get("profit_factor", 0)
            max_drawdown = performance.get("max_drawdown", 0)
            sharpe_ratio = performance.get("sharpe_ratio", 0)
            
            # Emoji pour le r√©sultat global
            result_emoji = "üü¢" if total_return > 0 else "üî¥" if total_return < 0 else "‚ö™"
            
            # Construire le message
            message = f"{result_emoji} <b>R√©sultats du Backtest</b>\n\n"
            
            # Informations de base
            message += f"<b>Strat√©gie:</b> {strategy.title()}\n"
            message += f"<b>P√©riode:</b> {options['start_date']} ‚Üí {options['end_date']}\n"
            message += f"<b>Blockchain:</b> {options['chain'].title()}\n"
            message += f"<b>Capital Initial:</b> {options['capital']:,.2f} USD\n\n"
            
            # Performances
            message += "<b>Performances:</b>\n"
            message += f"‚Ä¢ Capital Final: {options['capital'] * (1 + total_return/100):,.2f} USD\n"
            message += f"‚Ä¢ Rendement Total: {total_return:+.2f}%\n"
            message += f"‚Ä¢ Nombre de Trades: {total_trades}\n"
            message += f"‚Ä¢ Win Rate: {win_rate:.1f}%\n"
            message += f"‚Ä¢ Profit Factor: {profit_factor:.2f}\n"
            message += f"‚Ä¢ Drawdown Max: {max_drawdown:.2f}%\n"
            message += f"‚Ä¢ Ratio de Sharpe: {sharpe_ratio:.2f}\n"
            
            # Statistiques d√©taill√©es si demand√©es
            if options["detailed"] and "detailed_stats" in performance:
                stats = performance["detailed_stats"]
                message += "\n<b>Statistiques D√©taill√©es:</b>\n"
                
                if "monthly_returns" in stats:
                    message += "\n<b>Rendements Mensuels:</b>\n"
                    for month, ret in stats["monthly_returns"].items():
                        message += f"‚Ä¢ {month}: {ret:+.2f}%\n"
                
                if "best_trades" in stats:
                    message += "\n<b>Meilleurs Trades:</b>\n"
                    for trade in stats["best_trades"][:3]:  # Top 3
                        message += (
                            f"‚Ä¢ {trade['symbol']}: {trade['return']:+.2f}% "
                            f"({trade['date']})\n"
                        )
                
                if "worst_trades" in stats:
                    message += "\n<b>Pires Trades:</b>\n"
                    for trade in stats["worst_trades"][:3]:  # Top 3
                        message += (
                            f"‚Ä¢ {trade['symbol']}: {trade['return']:+.2f}% "
                            f"({trade['date']})\n"
                        )
            
            # Boutons pour actions suppl√©mentaires
            keyboard = [
                [InlineKeyboardButton("üìä Graphique de Performance", callback_data=f"backtest_chart_{strategy}")],
                [InlineKeyboardButton("üìà Analyse D√©taill√©e", callback_data=f"backtest_analysis_{strategy}")],
                [InlineKeyboardButton("üíæ Exporter R√©sultats", callback_data=f"backtest_export_{strategy}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Envoyer la r√©ponse et supprimer le message de processing
            await processing_message.delete()
            await update.message.reply_text(message, parse_mode="HTML", reply_markup=reply_markup)
        else:
            await processing_message.delete()
            await update.message.reply_text(
                "‚ùå <b>Erreur lors du backtest</b>\n\n"
                "Aucun r√©sultat n'a √©t√© obtenu. V√©rifiez les param√®tres et r√©essayez.",
                parse_mode="HTML"
            )
    except Exception as e:
        logger.error(f"Erreur lors du backtest: {str(e)}")
        traceback.print_exc()
        await processing_message.delete()
        await update.message.reply_text(
            f"‚ùå <b>Erreur lors du backtest</b>\n\n"
            f"D√©tails: {str(e)}",
            parse_mode="HTML"
        )

# Commande /list_backtests - Liste les backtests r√©cents
async def list_backtests_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Liste les backtests r√©cents et leurs r√©sultats.
    Usage: /list_backtests [options]
    Options: --limit=10, --strategy=sniper
    """
    user = update.effective_user
    chat_id = update.effective_chat.id
    
    # V√©rifier l'autorisation
    if hasattr(context.bot_data.get('bot'), '_is_user_authorized'):
        if not context.bot_data.get('bot')._is_user_authorized(user.id):
            await update.message.reply_text("‚õî Vous n'√™tes pas autoris√© √† utiliser cette commande.")
            return
    
    # V√©rifier si le module de backtesting est disponible
    if not BACKTESTING_AVAILABLE:
        await update.message.reply_text(
            "‚ùå <b>Module de backtesting non disponible</b>\n\n"
            "Cette fonctionnalit√© n√©cessite l'installation du module de backtesting.",
            parse_mode="HTML"
        )
        return
    
    # Extraire les options
    limit = 10
    strategy = None
    
    if context.args:
        for arg in context.args:
            if arg.startswith("--limit="):
                try:
                    limit = int(arg.split("=")[1])
                    limit = max(1, min(limit, 50))  # Limiter entre 1 et 50
                except ValueError:
                    pass
            elif arg.startswith("--strategy="):
                strategy = arg.split("=")[1].lower()
    
    try:
        # Cr√©er le moteur de backtesting
        engine = BacktestingEngine(context.bot_data.get('bot_state', {}))
        
        # R√©cup√©rer l'historique des backtests
        backtests = await engine.get_backtest_history(limit=limit, strategy=strategy)
        
        if backtests and len(backtests) > 0:
            # Construire le message
            message = "üìã <b>Historique des Backtests</b>\n\n"
            
            # Filtrer par strat√©gie si sp√©cifi√©
            if strategy:
                message += f"Strat√©gie: {strategy.title()}\n\n"
            
            # Lister les backtests
            for i, test in enumerate(backtests, 1):
                # Emoji pour le r√©sultat
                result_emoji = "üü¢" if test["return"] > 0 else "üî¥" if test["return"] < 0 else "‚ö™"
                
                message += (
                    f"{i}. {result_emoji} <b>{test['strategy'].title()}</b>\n"
                    f"   üìÖ {test['date']}\n"
                    f"   üí∞ Return: {test['return']:+.2f}%\n"
                    f"   üìä Trades: {test['trades']} (Win Rate: {test['win_rate']:.1f}%)\n"
                )
                
                # Ajouter un s√©parateur entre les backtests sauf pour le dernier
                if i < len(backtests):
                    message += "\n"
            
            # Boutons pour filtrer par strat√©gie
            keyboard = []
            strategies = ["all", "sniper", "arbitrage", "profit_taker", "auto"]
            strategy_buttons = []
            
            for s in strategies:
                if s != strategy:  # Ne pas afficher la strat√©gie actuelle
                    emoji = "üîÑ" if s == "all" else "üéØ" if s == "sniper" else "‚öñÔ∏è" if s == "arbitrage" else "üí∞" if s == "profit_taker" else "ü§ñ"
                    strategy_buttons.append(InlineKeyboardButton(f"{emoji} {s.title()}", callback_data=f"list_backtests_{s}_{limit}"))
            
            # Diviser les boutons en rang√©es de 3 maximum
            for i in range(0, len(strategy_buttons), 3):
                keyboard.append(strategy_buttons[i:i+3])
            
            # Ajouter un bouton pour lancer un nouveau backtest
            keyboard.append([InlineKeyboardButton("üîÑ Nouveau Backtest", callback_data="run_backtest")])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Envoyer la r√©ponse
            await update.message.reply_text(message, parse_mode="HTML", reply_markup=reply_markup)
        else:
            await update.message.reply_text(
                "‚ÑπÔ∏è <b>Aucun backtest trouv√©</b>\n\n"
                "Aucun backtest n'a √©t√© ex√©cut√© avec les crit√®res sp√©cifi√©s.",
                parse_mode="HTML"
            )
    except Exception as e:
        logger.error(f"Erreur lors de la r√©cup√©ration de l'historique des backtests: {str(e)}")
        traceback.print_exc()
        await update.message.reply_text(
            "‚ùå <b>Erreur lors de la r√©cup√©ration de l'historique</b>\n\n"
            f"D√©tails: {str(e)}",
            parse_mode="HTML"
        )

# Gestionnaire pour les callbacks li√©s aux backtests
async def backtest_button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    G√®re les callbacks des boutons li√©s aux backtests.
    """
    query = update.callback_query
    await query.answer()
    
    user = update.effective_user
    
    # V√©rifier l'autorisation
    if hasattr(context.bot_data.get('bot'), '_is_user_authorized'):
        if not context.bot_data.get('bot')._is_user_authorized(user.id):
            await query.edit_message_text("‚õî Vous n'√™tes pas autoris√© √† utiliser cette fonction.")
            return
    
    # Traiter la callback data
    callback_data = query.data
    
    if callback_data.startswith("backtest_chart_"):
        # Format: backtest_chart_<strategy>
        strategy = callback_data.replace("backtest_chart_", "")
        
        # Message de processing
        await query.edit_message_text(
            f"üìä <b>G√©n√©ration du graphique de performance...</b>\n\n"
            "Veuillez patienter pendant que je pr√©pare le graphique.",
            parse_mode="HTML"
        )
        
        try:
            # Cette fonctionnalit√© n√©cessiterait d'envoyer une image de graphique
            # Comme Telegram ne peut pas afficher d'images directement dans les messages √©dit√©s,
            # On pourrait soit envoyer un nouveau message avec l'image, soit proposer un lien de t√©l√©chargement
            
            # Pour l'instant, simulons cette fonctionnalit√© avec un message d'information
            message = (
                f"üìä <b>Graphique de Performance - {strategy.title()}</b>\n\n"
                "Le graphique de performance serait affich√© ici.\n\n"
                "Pour t√©l√©charger le graphique complet:\n"
                "‚Ä¢ Utilisez la commande <code>/export_backtest_chart</code>\n"
                "‚Ä¢ Ou cliquez sur le bouton ci-dessous"
            )
            
            # Boutons pour actions suppl√©mentaires
            keyboard = [
                [InlineKeyboardButton("üíæ T√©l√©charger Graphique", callback_data=f"download_chart_{strategy}")],
                [InlineKeyboardButton("‚óÄÔ∏è Retour aux R√©sultats", callback_data=f"backtest_results_{strategy}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(message, parse_mode="HTML", reply_markup=reply_markup)
        except Exception as e:
            logger.error(f"Erreur lors de la g√©n√©ration du graphique: {str(e)}")
            traceback.print_exc()
            await query.edit_message_text(
                "‚ùå <b>Erreur lors de la g√©n√©ration du graphique</b>\n\n"
                f"D√©tails: {str(e)}",
                parse_mode="HTML"
            )
    
    elif callback_data.startswith("backtest_analysis_"):
        # Format: backtest_analysis_<strategy>
        strategy = callback_data.replace("backtest_analysis_", "")
        
        # Message de processing
        await query.edit_message_text(
            f"üîç <b>G√©n√©ration de l'analyse d√©taill√©e...</b>\n\n"
            "Veuillez patienter pendant que je pr√©pare l'analyse approfondie.",
            parse_mode="HTML"
        )
        
        try:
            # Cr√©er le moteur de backtesting et l'analyseur de performance
            engine = BacktestingEngine(context.bot_data.get('bot_state', {}))
            analyzer = PerformanceAnalyzer()
            
            # R√©cup√©rer les r√©sultats d√©taill√©s du dernier backtest pour cette strat√©gie
            results = await engine.get_last_backtest_results(strategy)
            if results:
                # Analyser les performances en d√©tail
                analysis = await analyzer.analyze_results(results, detailed=True)
                
                if analysis:
                    # Formater l'analyse d√©taill√©e
                    message = f"üìä <b>Analyse D√©taill√©e - {strategy.title()}</b>\n\n"
                    
                    # Ajouter les diff√©rentes sections d'analyse
                    # (code similaire √† la commande de base, mais avec plus de d√©tails)
                    
                    # Boutons pour actions suppl√©mentaires
                    keyboard = [
                        [InlineKeyboardButton("üìä Voir Graphique", callback_data=f"backtest_chart_{strategy}")],
                        [InlineKeyboardButton("‚óÄÔ∏è Retour aux R√©sultats", callback_data=f"backtest_results_{strategy}")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await query.edit_message_text(message, parse_mode="HTML", reply_markup=reply_markup)
                else:
                    await query.edit_message_text(
                        "‚ùå <b>Erreur lors de l'analyse d√©taill√©e</b>\n\n"
                        "Impossible d'analyser les r√©sultats du backtest.",
                        parse_mode="HTML"
                    )
            else:
                await query.edit_message_text(
                    "‚ùå <b>Aucun r√©sultat trouv√©</b>\n\n"
                    "Aucun backtest r√©cent n'a √©t√© trouv√© pour cette strat√©gie.",
                    parse_mode="HTML"
                )
        except Exception as e:
            logger.error(f"Erreur lors de l'analyse d√©taill√©e: {str(e)}")
            traceback.print_exc()
            await query.edit_message_text(
                "‚ùå <b>Erreur lors de l'analyse d√©taill√©e</b>\n\n"
                f"D√©tails: {str(e)}",
                parse_mode="HTML"
            )
    
    elif callback_data.startswith("backtest_export_"):
        # Format: backtest_export_<strategy>
        strategy = callback_data.replace("backtest_export_", "")
        
        # Message de processing
        await query.edit_message_text(
            f"üíæ <b>Pr√©paration de l'export...</b>\n\n"
            "Veuillez patienter pendant que je pr√©pare les fichiers d'export.",
            parse_mode="HTML"
        )
        
        try:
            # Cr√©er le moteur de backtesting
            engine = BacktestingEngine(context.bot_data.get('bot_state', {}))
            
            # R√©cup√©rer les r√©sultats du dernier backtest pour cette strat√©gie
            results = await engine.get_last_backtest_results(strategy)
            
            if results:
                # Pr√©parer les diff√©rents formats d'export
                message = (
                    f"üíæ <b>Export des R√©sultats - {strategy.title()}</b>\n\n"
                    "Choisissez le format d'export souhait√©:\n\n"
                    "‚Ä¢ CSV: Donn√©es brutes pour analyse dans Excel\n"
                    "‚Ä¢ JSON: Format complet pour import/export\n"
                    "‚Ä¢ PDF: Rapport d√©taill√© avec graphiques\n"
                    "‚Ä¢ HTML: Version web interactive"
                )
                
                # Boutons pour les diff√©rents formats
                keyboard = [
                    [
                        InlineKeyboardButton("üìä CSV", callback_data=f"export_csv_{strategy}"),
                        InlineKeyboardButton("üîß JSON", callback_data=f"export_json_{strategy}"),
                        InlineKeyboardButton("üìÑ PDF", callback_data=f"export_pdf_{strategy}"),
                        InlineKeyboardButton("üåê HTML", callback_data=f"export_html_{strategy}")
                    ],
                    [InlineKeyboardButton("‚óÄÔ∏è Retour aux R√©sultats", callback_data=f"backtest_results_{strategy}")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(message, parse_mode="HTML", reply_markup=reply_markup)
            else:
                await query.edit_message_text(
                    "‚ùå <b>Aucun r√©sultat √† exporter</b>\n\n"
                    "Aucun backtest r√©cent n'a √©t√© trouv√© pour cette strat√©gie.",
                    parse_mode="HTML"
                )
        except Exception as e:
            logger.error(f"Erreur lors de la pr√©paration de l'export: {str(e)}")
            traceback.print_exc()
            await query.edit_message_text(
                "‚ùå <b>Erreur lors de la pr√©paration de l'export</b>\n\n"
                f"D√©tails: {str(e)}",
                parse_mode="HTML"
            )
    
    elif callback_data.startswith("list_backtests_"):
        # Format: list_backtests_<strategy>_<limit>
        parts = callback_data.split("_")
        if len(parts) >= 3:
            strategy = parts[2]
            limit = int(parts[3]) if len(parts) > 3 and parts[3].isdigit() else 10
            
            # Rediriger vers la commande list_backtests avec les bons param√®tres
            context.args = []
            if strategy != "all":
                context.args.append(f"--strategy={strategy}")
            context.args.append(f"--limit={limit}")
            
            await list_backtests_command(update, context)

# Fonction pour enregistrer les gestionnaires de commandes
def register_backtest_command_handlers(application):
    """
    Enregistre les gestionnaires de commandes li√©es au backtesting.
    """
    application.add_handler(CommandHandler("run_backtest", run_backtest_command))
    application.add_handler(CommandHandler("list_backtests", list_backtests_command))
    
    # Gestionnaire pour les callbacks des boutons
    application.add_handler(CallbackQueryHandler(
        backtest_button_callback,
        pattern="^(backtest_|list_backtests_|export_)"
    )) 