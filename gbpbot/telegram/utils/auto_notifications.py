"""
Utilitaires pour les notifications d'automatisation intelligente via Telegram.

Ce module fournit des fonctions pour envoyer des notifications automatiques
concernant le syst√®me d'automatisation intelligente du GBPBot via Telegram.
"""

import logging
from typing import Dict, Any, Optional, List, Union
from datetime import datetime
from telegram import InlineKeyboardButton, InlineKeyboardMarkup

from gbpbot.telegram import send_notification

logger = logging.getLogger(__name__)

def format_market_conditions(market_conditions: Dict[str, str]) -> str:
    """
    Formate les conditions de march√© pour l'affichage dans une notification.
    
    Args:
        market_conditions: Dictionnaire de conditions de march√©
        
    Returns:
        Message format√© pour l'affichage
    """
    if not market_conditions:
        return "Conditions de march√©: Non d√©tect√©es"
    
    # Indicateurs visuels pour les conditions
    volatility = market_conditions.get('volatility', 'inconnue')
    trend = market_conditions.get('trend', 'inconnue')
    liquidity = market_conditions.get('liquidity', 'inconnue')
    opportunity = market_conditions.get('opportunity', 'inconnue')
    risk = market_conditions.get('risk', 'inconnue')
    
    volatility_emoji = {"low": "üü¢", "normal": "üü°", "high": "üü†", "extreme": "üî¥"}.get(volatility, "‚ö™")
    trend_emoji = {"bearish": "üî¥", "neutral": "üü°", "bullish": "üü¢"}.get(trend, "‚ö™")
    liquidity_emoji = {"low": "üî¥", "normal": "üü°", "high": "üü¢"}.get(liquidity, "‚ö™")
    opportunity_emoji = {"low": "üî¥", "medium": "üü°", "high": "üü¢"}.get(opportunity, "‚ö™")
    risk_emoji = {"low": "üü¢", "medium": "üü°", "high": "üî¥"}.get(risk, "‚ö™")
    
    message = "*Conditions de march√© d√©tect√©es:*\n"
    message += f"‚Ä¢ Volatilit√©: {volatility_emoji} {volatility.upper()}\n"
    message += f"‚Ä¢ Tendance: {trend_emoji} {trend.upper()}\n"
    message += f"‚Ä¢ Liquidit√©: {liquidity_emoji} {liquidity.upper()}\n"
    message += f"‚Ä¢ Opportunit√©s: {opportunity_emoji} {opportunity.upper()}\n"
    message += f"‚Ä¢ Risque: {risk_emoji} {risk.upper()}"
    
    return message

def notify_market_conditions_change(bot_context: Dict[str, Any], market_conditions: Dict[str, str]) -> None:
    """
    Envoie une notification lorsque les conditions de march√© changent significativement.
    
    Args:
        bot_context: Contexte du bot
        market_conditions: Nouvelles conditions de march√©
    """
    # V√©rifier si les notifications sont activ√©es
    config = bot_context.get('config', {}).get('auto_optimization', {})
    notify_market_changes = config.get('notify_market_changes', True)
    
    if not notify_market_changes:
        logger.debug("Notifications de changement de march√© d√©sactiv√©es")
        return
    
    # V√©rifier si les conditions ont suffisamment chang√© pour justifier une notification
    prev_conditions = bot_context.get('prev_market_conditions', {})
    
    significant_change = False
    
    # V√©rifier les changements importants
    for key in ['volatility', 'trend', 'risk']:
        if key in market_conditions and key in prev_conditions:
            if market_conditions[key] != prev_conditions.get(key):
                significant_change = True
                break
    
    if not significant_change and prev_conditions:
        logger.debug("Pas de changement significatif des conditions de march√©")
        return
    
    # Mettre √† jour les conditions pr√©c√©dentes
    bot_context['prev_market_conditions'] = market_conditions.copy()
    
    # Cr√©er le message
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    message = (
        f"üîÑ *Changement des conditions de march√©* - {timestamp}\n\n"
        f"{format_market_conditions(market_conditions)}\n\n"
    )
    
    # Ajouter des recommandations selon les conditions
    if market_conditions.get('volatility') == 'high' or market_conditions.get('volatility') == 'extreme':
        message += "\n‚ö†Ô∏è *Forte volatilit√© d√©tect√©e* - Ajustement automatique des strat√©gies en cours..."
    
    if market_conditions.get('risk') == 'high':
        message += "\nüõë *Risque √©lev√© d√©tect√©* - R√©duction automatique de l'exposition..."
    
    if market_conditions.get('opportunity') == 'high' and market_conditions.get('risk') != 'high':
        message += "\n‚ú® *Opportunit√©s √©lev√©es d√©tect√©es* - Augmentation de l'allocation de capital..."
    
    # Ajouter un clavier pour les actions
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üìä Voir d√©tails", callback_data="auto_status")],
        [InlineKeyboardButton("‚öôÔ∏è Configurer", callback_data="auto_config")]
    ])
    
    # Envoyer la notification
    send_notification(bot_context, message, keyboard)
    logger.info("Notification de changement de conditions de march√© envoy√©e")

def notify_parameter_adjustment(bot_context: Dict[str, Any], strategy: str, params_changed: Dict[str, Dict[str, Any]]) -> None:
    """
    Envoie une notification lorsque des param√®tres de strat√©gie sont ajust√©s automatiquement.
    
    Args:
        bot_context: Contexte du bot
        strategy: Nom de la strat√©gie modifi√©e
        params_changed: Dictionnaire des param√®tres modifi√©s avec leurs anciennes et nouvelles valeurs
    """
    # V√©rifier si les notifications sont activ√©es
    config = bot_context.get('config', {}).get('auto_optimization', {})
    notify_parameter_changes = config.get('notify_parameter_changes', True)
    
    if not notify_parameter_changes:
        logger.debug("Notifications de changement de param√®tres d√©sactiv√©es")
        return
    
    # Cr√©er le message
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    message = (
        f"‚öôÔ∏è *Ajustement automatique des param√®tres* - {timestamp}\n\n"
        f"*Strat√©gie:* {strategy}\n\n"
        "*Param√®tres ajust√©s:*\n"
    )
    
    # Ajouter les d√©tails des param√®tres modifi√©s
    for param, details in params_changed.items():
        old_value = details.get('old')
        new_value = details.get('new')
        reason = details.get('reason', 'Optimisation bas√©e sur les conditions actuelles')
        
        message += f"‚Ä¢ *{param}*:\n"
        message += f"  - Avant: `{old_value}`\n"
        message += f"  - Apr√®s: `{new_value}`\n"
        message += f"  - Raison: {reason}\n\n"
    
    # Ajouter un clavier pour les actions
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üìä Voir d√©tails", callback_data="auto_status")],
        [InlineKeyboardButton("‚Ü©Ô∏è Annuler changements", callback_data="auto_revert")]
    ])
    
    # Envoyer la notification
    send_notification(bot_context, message, keyboard)
    logger.info(f"Notification d'ajustement de param√®tres pour {strategy} envoy√©e")

def notify_capital_allocation(bot_context: Dict[str, Any], allocations: Dict[str, float], 
                             previous_allocations: Dict[str, float]) -> None:
    """
    Envoie une notification lorsque l'allocation de capital est modifi√©e.
    
    Args:
        bot_context: Contexte du bot
        allocations: Nouvelles allocations par strat√©gie
        previous_allocations: Anciennes allocations par strat√©gie
    """
    # V√©rifier si les notifications sont activ√©es
    config = bot_context.get('config', {}).get('auto_optimization', {})
    notify_allocation_changes = config.get('notify_allocation_changes', True)
    
    if not notify_allocation_changes:
        logger.debug("Notifications de changement d'allocation d√©sactiv√©es")
        return
    
    # V√©rifier si les allocations ont suffisamment chang√©
    significant_change = False
    for strategy, allocation in allocations.items():
        prev_allocation = previous_allocations.get(strategy, 0.0)
        if abs(allocation - prev_allocation) > 0.05:  # 5% de changement minimum
            significant_change = True
            break
    
    if not significant_change:
        logger.debug("Pas de changement significatif dans l'allocation de capital")
        return
    
    # Cr√©er le message
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    message = (
        f"üí∞ *R√©allocation automatique du capital* - {timestamp}\n\n"
        "*Nouvelles allocations:*\n"
    )
    
    # Ajouter les d√©tails des allocations
    for strategy, allocation in allocations.items():
        prev_allocation = previous_allocations.get(strategy, 0.0)
        change = allocation - prev_allocation
        change_text = f"(+{change:.1%})" if change > 0 else f"({change:.1%})"
        
        # Emoji bas√© sur le changement
        emoji = "üî∫" if change > 0.1 else "üîª" if change < -0.1 else "‚ÜîÔ∏è"
        
        message += f"‚Ä¢ *{strategy}*: {allocation:.1%} {change_text} {emoji}\n"
    
    # Ajouter la raison
    auto_optimizer = bot_context.get('auto_optimizer')
    market_conditions = {}
    
    if auto_optimizer:
        status = auto_optimizer.get_status()
        market_conditions = status.get('market_conditions', {})
    
    if market_conditions:
        message += f"\n{format_market_conditions(market_conditions)}"
    
    # Ajouter un clavier pour les actions
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üìä Voir d√©tails", callback_data="auto_status")],
        [InlineKeyboardButton("‚Ü©Ô∏è Annuler r√©allocation", callback_data="auto_revert_allocation")]
    ])
    
    # Envoyer la notification
    send_notification(bot_context, message, keyboard)
    logger.info("Notification de r√©allocation de capital envoy√©e")

def notify_error_recovery(bot_context: Dict[str, Any], error_type: str, action_taken: str, 
                         success: bool, details: str = "") -> None:
    """
    Envoie une notification lorsqu'un m√©canisme de r√©cup√©ration d'erreur est activ√©.
    
    Args:
        bot_context: Contexte du bot
        error_type: Type d'erreur rencontr√©e
        action_taken: Action entreprise pour r√©cup√©rer
        success: Si la r√©cup√©ration a r√©ussi
        details: D√©tails suppl√©mentaires
    """
    # V√©rifier si les notifications sont activ√©es
    config = bot_context.get('config', {}).get('auto_optimization', {})
    notify_error_recovery = config.get('notify_error_recovery', True)
    
    if not notify_error_recovery:
        logger.debug("Notifications de r√©cup√©ration d'erreur d√©sactiv√©es")
        return
    
    # Cr√©er le message
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    status_emoji = "‚úÖ" if success else "‚ùå"
    
    message = (
        f"üîß *R√©cup√©ration automatique d'erreur* - {timestamp}\n\n"
        f"*Type d'erreur:* {error_type}\n"
        f"*Action entreprise:* {action_taken}\n"
        f"*Statut:* {status_emoji} {'R√©ussite' if success else '√âchec'}\n"
    )
    
    if details:
        message += f"*D√©tails:* {details}\n"
    
    # Ajouter un clavier pour les actions
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üìä Voir l'√©tat syst√®me", callback_data="auto_status")],
        [InlineKeyboardButton("üîç Consulter les logs", callback_data="show_logs")]
    ])
    
    # Niveau de log en fonction du succ√®s
    if success:
        logger.info(f"R√©cup√©ration r√©ussie pour l'erreur {error_type}")
    else:
        logger.warning(f"√âchec de r√©cup√©ration pour l'erreur {error_type}")
    
    # Envoyer la notification
    send_notification(bot_context, message, keyboard)

def notify_performance_report(bot_context: Dict[str, Any], performance_data: Dict[str, Any]) -> None:
    """
    Envoie un rapport de performance automatis√© via Telegram.
    
    Args:
        bot_context: Contexte du bot
        performance_data: Donn√©es de performance √† inclure dans le rapport
    """
    # V√©rifier si les notifications sont activ√©es
    config = bot_context.get('config', {}).get('auto_optimization', {})
    notify_performance = config.get('notify_performance_reports', True)
    
    if not notify_performance:
        logger.debug("Notifications de rapport de performance d√©sactiv√©es")
        return
    
    # Extraire les donn√©es de performance
    total_pnl = performance_data.get('total_pnl', 0.0)
    period_pnl = performance_data.get('period_pnl', 0.0)
    period_text = performance_data.get('period', '24h')
    strategies = performance_data.get('strategies', {})
    
    # Cr√©er le message
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Emoji bas√© sur la performance
    emoji = "üî•" if period_pnl > 5.0 else "üìà" if period_pnl > 0 else "üìâ" if period_pnl < 0 else "‚ÜîÔ∏è"
    
    message = (
        f"{emoji} *Rapport de Performance Automatis√©* - {timestamp}\n\n"
        f"*Performance {period_text}:* {period_pnl:+.2f}%\n"
        f"*PnL total:* {total_pnl:+.2f}%\n\n"
    )
    
    # Ajouter les performances par strat√©gie
    if strategies:
        message += "*Performance par strat√©gie:*\n"
        
        for strategy, data in strategies.items():
            strategy_pnl = data.get('pnl', 0.0)
            trades = data.get('trades', 0)
            win_rate = data.get('win_rate', 0.0)
            
            # Emoji bas√© sur la performance de la strat√©gie
            strategy_emoji = "üü¢" if strategy_pnl > 3.0 else "üü°" if strategy_pnl > 0 else "üî¥"
            
            message += f"‚Ä¢ {strategy_emoji} *{strategy}*: {strategy_pnl:+.2f}% ({trades} trades, {win_rate:.1f}% win)\n"
    
    # Ajouter les recommandations d'optimisation
    recommendations = performance_data.get('recommendations', [])
    
    if recommendations:
        message += "\n*Recommandations d'optimisation:*\n"
        
        for rec in recommendations:
            message += f"‚Ä¢ {rec}\n"
    
    # Ajouter un clavier pour les actions
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üìä Voir rapport d√©taill√©", callback_data="trading_stats")],
        [InlineKeyboardButton("‚öôÔ∏è Optimisations recommand√©es", callback_data="auto_recommendations")]
    ])
    
    # Envoyer la notification
    send_notification(bot_context, message, keyboard)
    logger.info("Rapport de performance automatis√© envoy√©")

__all__ = [
    'notify_market_conditions_change',
    'notify_parameter_adjustment',
    'notify_capital_allocation',
    'notify_error_recovery',
    'notify_performance_report',
] 