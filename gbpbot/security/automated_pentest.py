#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Module de tests de pénétration automatisés pour GBPBot
======================================================

Ce module implémente une suite de tests de pénétration automatisés 
pour évaluer la sécurité de l'API GBPBot et de ses interfaces.
Il utilise unittest pour faciliter l'exécution et le reporting des tests.

Les tests incluent:
- Injections SQL
- Injections de commandes
- Attaques XSS (Cross-Site Scripting)
- Tests des méthodes HTTP invalides
- Fuzzing des paramètres d'API
- Tests de validation d'entrée
- Tests d'authentification et d'autorisation

Usage:
    python -m unittest gbpbot.security.automated_pentest
    
    # Pour exécuter un test spécifique:
    python -m unittest gbpbot.security.automated_pentest.AutomatedPenTest.test_sql_injection
"""

import os
import unittest
import logging
import json
import re
import requests
import socket
import ssl
import random
import string
import time
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path
from urllib.parse import urljoin
from dotenv import load_dotenv

# Configuration du logger
logger = logging.getLogger("AutomatedPenTest")
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)
file_handler = logging.FileHandler("pentest_results.log")
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)

class AutomatedPenTest(unittest.TestCase):
    """Classe de tests de pénétration pour GBPBot."""

    api_url: str
    api_key: str
    timeout: int = 5
    results: Dict[str, List[Dict[str, Any]]] = {}
    
    @classmethod
    def setUpClass(cls) -> None:
        """Configuration initiale pour tous les tests."""
        load_dotenv()
        cls.api_url = os.getenv("GBPBOT_API_URL", "http://127.0.0.1:5000")
        cls.api_key = os.getenv("GBPBOT_API_KEY", "your_secure_api_key_here")
        cls.results = {
            "auth_tests": [],
            "injection_tests": [],
            "method_tests": [],
            "input_validation_tests": [],
            "csrf_tests": [],
            "rate_limit_tests": []
        }
        logger.info(f"Configuration des tests de pénétration pour l'API: {cls.api_url}")
    
    def setUp(self) -> None:
        """Configuration pour chaque test individuel."""
        # Attente entre les tests pour éviter de surcharger l'API
        time.sleep(0.5)
        
    def test_sql_injection(self) -> None:
        """Test de résistance aux injections SQL."""
        logger.info("Test d'injection SQL...")
        
        # Payloads d'injection SQL courants
        sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "' UNION SELECT NULL, NULL, NULL --",
            "admin' --",
            "1'; DROP TABLE users; --",
            "1'; SELECT * FROM information_schema.tables; --",
            "' OR 1=1 LIMIT 1 --",
            "') OR ('x'='x",
            "')) OR (('x'='x"
        ]
        
        endpoints = ["/api/status", "/api/wallet", "/api/transactions"]
        
        for endpoint in endpoints:
            for payload in sql_payloads:
                try:
                    headers = {"x-api-key": self.api_key}
                    params = {"token": payload, "query": payload, "wallet": payload}
                    
                    url = urljoin(self.api_url, endpoint)
                    response = requests.get(url, headers=headers, params=params, timeout=self.timeout)
                    
                    # Vérifier si l'injection a réussi (erreur SQL ou résultats inattendus)
                    self.assertNotIn("syntax error", response.text.lower())
                    self.assertNotIn("sql syntax", response.text.lower())
                    self.assertNotIn("unclosed quotation", response.text.lower())
                    self.assertNotIn("quoted string not properly terminated", response.text.lower())
                    
                    # Vérifier si le code de statut indique une erreur serveur (500)
                    self.assertNotEqual(response.status_code, 500)
                    
                    logger.info(f"Endpoint {endpoint} sécurisé contre l'injection SQL: {payload}")
                except Exception as e:
                    logger.error(f"Erreur lors du test d'injection SQL sur {endpoint}: {e}")
                    self.fail(f"Le test d'injection SQL a échoué sur {endpoint}: {e}")
    
    def test_command_injection(self) -> None:
        """Test de résistance aux injections de commandes."""
        logger.info("Test d'injection de commandes...")
        
        # Payloads d'injection de commandes courants
        cmd_payloads = [
            "| ls -la",
            "; ls -la",
            "` ls -la `",
            "$( ls -la )",
            "&& ls -la",
            "|| ls -la",
            "> /tmp/hack",
            "< /etc/passwd",
            "| cat /etc/passwd",
            "; ping -c 3 8.8.8.8",
            "& echo vulnerable &",
            "%0A cat /etc/passwd"
        ]
        
        endpoints = ["/api/execute", "/api/config", "/api/script"]
        
        for endpoint in endpoints:
            for payload in cmd_payloads:
                try:
                    headers = {"x-api-key": self.api_key}
                    params = {"command": payload, "script": payload, "config": payload}
                    
                    url = urljoin(self.api_url, endpoint)
                    response = requests.post(url, headers=headers, json=params, timeout=self.timeout)
                    
                    # Vérifier si l'injection a réussi (résultats de commandes visibles)
                    self.assertNotIn("/etc/passwd", response.text)
                    self.assertNotIn("root:", response.text)
                    self.assertNotIn("drwx", response.text)
                    self.assertNotIn("bin", response.text.lower())
                    
                    # Vérifier si le code de statut indique une erreur serveur (500)
                    self.assertNotEqual(response.status_code, 500)
                    
                    logger.info(f"Endpoint {endpoint} sécurisé contre l'injection de commandes: {payload}")
                except requests.exceptions.RequestException:
                    # Si l'endpoint n'existe pas, on continue
                    logger.info(f"Endpoint {endpoint} non disponible")
                    continue
                except Exception as e:
                    logger.error(f"Erreur lors du test d'injection de commandes sur {endpoint}: {e}")
                    self.fail(f"Le test d'injection de commandes a échoué sur {endpoint}: {e}")
    
    def test_xss_injection(self) -> None:
        """Test de résistance aux attaques XSS."""
        logger.info("Test d'injection XSS...")
        
        # Payloads XSS courants
        xss_payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)",
            "\"><script>alert(1)</script>",
            "';alert(1);//",
            "<body onload=alert(1)>",
            "<iframe src=javascript:alert(1)>",
            "<a href='javascript:alert(1)'>XSS</a>",
            "<div style='background-image:url(javascript:alert(1))'>"
        ]
        
        endpoints = ["/api/message", "/api/profile", "/api/feedback"]
        
        for endpoint in endpoints:
            for payload in xss_payloads:
                try:
                    headers = {"x-api-key": self.api_key}
                    params = {"message": payload, "name": payload, "comment": payload}
                    
                    url = urljoin(self.api_url, endpoint)
                    response = requests.post(url, headers=headers, json=params, timeout=self.timeout)
                    
                    # Vérifier si l'injection a été nettoyée/échappée
                    if '<script>' in payload:
                        self.assertNotIn('<script>', response.text)
                    
                    # Vérifier que le payload ne se retrouve pas tel quel dans la réponse
                    if response.headers.get('content-type', '').startswith('text/html'):
                        self.assertNotIn(payload, response.text)
                    
                    logger.info(f"Endpoint {endpoint} sécurisé contre l'attaque XSS: {payload}")
                except requests.exceptions.RequestException:
                    # Si l'endpoint n'existe pas, on continue
                    logger.info(f"Endpoint {endpoint} non disponible")
                    continue
                except Exception as e:
                    logger.error(f"Erreur lors du test d'injection XSS sur {endpoint}: {e}")
                    self.fail(f"Le test d'injection XSS a échoué sur {endpoint}: {e}")
    
    def test_invalid_http_method(self) -> None:
        """Test de résistance aux méthodes HTTP invalides."""
        logger.info("Test de méthodes HTTP invalides...")
        
        endpoints = ["/api/status", "/api/wallet", "/api/transactions"]
        methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD", "TRACE", "CONNECT"]
        
        for endpoint in endpoints:
            url = urljoin(self.api_url, endpoint)
            valid_methods = []
            
            # Détecter les méthodes valides avec OPTIONS
            try:
                options_response = requests.options(url, timeout=self.timeout)
                if 'Allow' in options_response.headers:
                    valid_methods = [m.strip() for m in options_response.headers['Allow'].split(',')]
            except:
                # Si OPTIONS échoue, on teste toutes les méthodes
                pass
            
            for method in methods:
                try:
                    headers = {"x-api-key": self.api_key}
                    response = requests.request(method, url, headers=headers, timeout=self.timeout)
                    
                    # Si la méthode n'est pas supportée, elle devrait retourner 405 Method Not Allowed
                    if method not in valid_methods and valid_methods:
                        self.assertEqual(response.status_code, 405, 
                                         f"L'endpoint {endpoint} accepte la méthode {method} alors qu'il ne devrait pas")
                    
                    logger.info(f"Endpoint {endpoint} a correctement géré la méthode {method}: {response.status_code}")
                except Exception as e:
                    logger.error(f"Erreur lors du test de méthode HTTP {method} sur {endpoint}: {e}")
    
    def test_authentication_bypass(self) -> None:
        """Test de tentatives de contournement de l'authentification."""
        logger.info("Test de contournement d'authentification...")
        
        endpoints = ["/api/wallet", "/api/transactions", "/api/config"]
        auth_headers = [
            {},  # Aucun header
            {"x-api-key": ""},  # Clé vide
            {"x-api-key": "invalid_key"},  # Clé invalide
            {"x-api-key": "null"},  # Valeur null
            {"x-api-key": "undefined"},  # Valeur undefined
            {"x-api-key": "' OR '1'='1"},  # Injection SQL
            {"authorization": f"Bearer {self.api_key}"},  # Mauvais format (Bearer au lieu de x-api-key)
            {"X-API-KEY": self.api_key}  # Case différente
        ]
        
        for endpoint in endpoints:
            url = urljoin(self.api_url, endpoint)
            
            # Test avec une clé valide d'abord pour vérifier que l'endpoint existe
            try:
                valid_response = requests.get(url, headers={"x-api-key": self.api_key}, timeout=self.timeout)
                endpoint_exists = valid_response.status_code != 404
            except:
                endpoint_exists = False
            
            if not endpoint_exists:
                logger.info(f"Endpoint {endpoint} non disponible, test ignoré")
                continue
            
            for headers in auth_headers:
                try:
                    response = requests.get(url, headers=headers, timeout=self.timeout)
                    
                    # Vérifier que l'authentification échoue correctement
                    if headers.get("x-api-key") != self.api_key:
                        self.assertIn(response.status_code, [401, 403], 
                                     f"L'endpoint {endpoint} n'a pas rejeté une tentative d'authentification invalide")
                    
                    logger.info(f"Endpoint {endpoint} a correctement géré la tentative d'authentification: {response.status_code}")
                except Exception as e:
                    logger.error(f"Erreur lors du test d'authentification sur {endpoint}: {e}")
    
    def test_path_traversal(self) -> None:
        """Test de résistance aux attaques de traversée de chemin."""
        logger.info("Test de traversée de chemin...")
        
        # Payloads de traversée de chemin
        traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\Windows\\win.ini",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "file:///etc/passwd",
            "/var/www/html/config.php",
            "C:\\Windows\\System32\\drivers\\etc\\hosts",
            "....\\....\\....\\Windows\\win.ini",
            "/../../../etc/passwd",
            "/..../..../..../etc/passwd"
        ]
        
        endpoints = [
            "/api/file", 
            "/api/config",
            "/api/logs",
            "/api/download"
        ]
        
        for endpoint in endpoints:
            for payload in traversal_payloads:
                try:
                    headers = {"x-api-key": self.api_key}
                    params = {"path": payload, "file": payload, "filename": payload}
                    
                    url = urljoin(self.api_url, endpoint)
                    response = requests.get(url, headers=headers, params=params, timeout=self.timeout)
                    
                    # Vérifier que le contenu sensible n'est pas exposé
                    self.assertNotIn("root:", response.text)
                    self.assertNotIn("[fonts]", response.text)
                    self.assertNotIn("localhost", response.text)
                    self.assertNotIn("password", response.text.lower())
                    
                    logger.info(f"Endpoint {endpoint} sécurisé contre la traversée de chemin: {payload}")
                except requests.exceptions.RequestException:
                    # Si l'endpoint n'existe pas, on continue
                    logger.info(f"Endpoint {endpoint} non disponible")
                    continue
                except Exception as e:
                    logger.error(f"Erreur lors du test de traversée de chemin sur {endpoint}: {e}")
    
    def test_rate_limiting(self) -> None:
        """Test des mécanismes de limitation de taux (rate limiting)."""
        logger.info("Test de rate limiting...")
        
        endpoints = ["/api/status", "/api/wallet", "/api/transactions"]
        requests_count = 50  # Nombre de requêtes à envoyer en rafale
        
        for endpoint in endpoints:
            url = urljoin(self.api_url, endpoint)
            headers = {"x-api-key": self.api_key}
            
            # Envoyer plusieurs requêtes rapidement
            start_time = time.time()
            rate_limited = False
            
            for i in range(requests_count):
                try:
                    response = requests.get(url, headers=headers, timeout=self.timeout)
                    
                    # Vérifier si une limitation de taux est détectée
                    if response.status_code == 429:  # Too Many Requests
                        rate_limited = True
                        logger.info(f"Rate limiting détecté sur {endpoint} après {i+1} requêtes")
                        break
                    
                    # Vérifier les en-têtes de limitation de taux
                    rate_limit_headers = [
                        'X-RateLimit-Limit',
                        'X-RateLimit-Remaining',
                        'X-RateLimit-Reset',
                        'Retry-After'
                    ]
                    
                    has_rate_limit_headers = any(h in response.headers for h in rate_limit_headers)
                    if has_rate_limit_headers:
                        logger.info(f"En-têtes de rate limiting détectés sur {endpoint}")
                        
                except Exception as e:
                    logger.error(f"Erreur lors du test de rate limiting sur {endpoint}: {e}")
                    break
            
            elapsed_time = time.time() - start_time
            
            # Vérifier si un mécanisme de limitation de taux est en place
            if not rate_limited:
                logger.warning(f"Aucun rate limiting détecté sur {endpoint} après {requests_count} requêtes en {elapsed_time:.2f} secondes")
            
            # Attendre un peu avant de passer à l'endpoint suivant
            time.sleep(5)
    
    def tearDown(self) -> None:
        """Nettoyage après chaque test."""
        pass
    
    @classmethod
    def tearDownClass(cls) -> None:
        """Nettoyage final et génération du rapport."""
        logger.info("Génération du rapport de tests de pénétration...")
        
        report = {
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "target_api": cls.api_url,
            "tests_results": cls.results,
            "summary": {
                "total_tests": sum(len(tests) for tests in cls.results.values()),
                "passed_tests": sum(1 for tests in cls.results.values() for test in tests if test.get("passed", False)),
                "failed_tests": sum(1 for tests in cls.results.values() for test in tests if not test.get("passed", False))
            }
        }
        
        # Enregistrer le rapport au format JSON
        with open("pentest_report.json", "w") as f:
            json.dump(report, f, indent=4)
        
        logger.info(f"Rapport enregistré dans pentest_report.json")
        logger.info(f"Tests terminés. Résumé: {report['summary']}")

def run_tests() -> None:
    """Exécute les tests de pénétration et génère un rapport."""
    unittest.main()

if __name__ == "__main__":
    run_tests() 