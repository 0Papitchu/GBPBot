#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script pour exécuter les tests de pénétration automatisés de GBPBot
==================================================================

Ce script permet de lancer facilement les tests de pénétration automatisés
et d'analyser les résultats pour identifier les vulnérabilités potentielles.

Usage:
    python run_pentest.py [--target URL] [--key API_KEY] [--output DIRECTORY] [--verbose]
"""

import os
import sys
import argparse
import json
import logging
import subprocess
import datetime
import shutil
from pathlib import Path

# Ajouter le répertoire parent au PYTHONPATH pour pouvoir importer gbpbot
sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

try:
    from gbpbot.security.automated_pentest import AutomatedPenTest, run_tests
    from gbpbot.utils.logger import setup_logger
except ImportError:
    print("Erreur: Impossible d'importer les modules nécessaires.")
    print("Assurez-vous d'exécuter ce script depuis le répertoire racine du projet.")
    sys.exit(1)

# Configuration du logger
logger = setup_logger("PenTest", logging.INFO)

def parse_arguments():
    """Analyse les arguments de ligne de commande"""
    parser = argparse.ArgumentParser(description="Exécute les tests de pénétration automatisés pour GBPBot")
    
    parser.add_argument("--target", dest="target_url", 
                        help="URL cible de l'API GBPBot (par défaut: valeur de GBPBOT_API_URL ou http://127.0.0.1:5000)")
    
    parser.add_argument("--key", dest="api_key",
                        help="Clé API pour authentification (par défaut: valeur de GBPBOT_API_KEY)")
    
    parser.add_argument("--output", dest="output_dir", default="security_reports/pentests",
                        help="Répertoire de sortie pour les rapports (par défaut: security_reports/pentests)")
    
    parser.add_argument("--verbose", dest="verbose", action="store_true",
                        help="Affiche des informations détaillées pendant l'exécution")
    
    parser.add_argument("--specific", dest="specific_test",
                        help="Exécute uniquement un test spécifique (ex: test_sql_injection)")
    
    parser.add_argument("--html", dest="html_report", action="store_true",
                        help="Génère un rapport HTML en plus du rapport JSON")
    
    return parser.parse_args()

def setup_environment(args):
    """Configure l'environnement pour les tests"""
    # Définir les variables d'environnement si spécifiées
    if args.target_url:
        os.environ["GBPBOT_API_URL"] = args.target_url
        logger.info(f"URL cible définie: {args.target_url}")
    
    if args.api_key:
        os.environ["GBPBOT_API_KEY"] = args.api_key
        logger.info("Clé API définie")
    
    # Créer le répertoire de sortie s'il n'existe pas
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    return output_dir

def run_specific_test(test_name):
    """Exécute un test spécifique"""
    import unittest
    
    logger.info(f"Exécution du test spécifique: {test_name}")
    
    suite = unittest.TestSuite()
    try:
        suite.addTest(AutomatedPenTest(test_name))
        runner = unittest.TextTestRunner(verbosity=2)
        result = runner.run(suite)
        
        return result.wasSuccessful()
    except AttributeError:
        logger.error(f"Test '{test_name}' non trouvé dans AutomatedPenTest")
        return False

def run_all_tests():
    """Exécute tous les tests de pénétration"""
    import unittest
    
    logger.info("Exécution de tous les tests de pénétration")
    
    suite = unittest.TestLoader().loadTestsFromTestCase(AutomatedPenTest)
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    return result.wasSuccessful()

def generate_html_report(json_report_path, output_dir):
    """Génère un rapport HTML à partir du rapport JSON"""
    json_path = Path(json_report_path)
    if not json_path.exists():
        logger.error(f"Fichier JSON non trouvé: {json_path}")
        return None
    
    try:
        with open(json_path, 'r') as f:
            report_data = json.load(f)
        
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        html_path = output_dir / f"pentest_report_{timestamp}.html"
        
        with open(html_path, 'w') as f:
            f.write("""<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rapport de Tests de Pénétration GBPBot</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        header {
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        header h1 {
            color: white;
            margin: 0;
        }
        .summary {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 5px solid #2c3e50;
        }
        .test-category {
            margin-bottom: 30px;
        }
        .test-result {
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 5px;
            background-color: #f2f2f2;
        }
        .test-passed {
            border-left: 5px solid #27ae60;
        }
        .test-failed {
            border-left: 5px solid #e74c3c;
        }
        .test-warning {
            border-left: 5px solid #f39c12;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #2c3e50;
            color: white;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .footer {
            margin-top: 30px;
            text-align: center;
            font-size: 0.9em;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Rapport de Tests de Pénétration GBPBot</h1>
            <p>Généré le: """ + report_data["timestamp"] + """</p>
        </header>

        <div class="summary">
            <h2>Résumé</h2>
            <p><strong>API Cible:</strong> """ + report_data["target_api"] + """</p>
            <p><strong>Tests Totaux:</strong> """ + str(report_data["summary"]["total_tests"]) + """</p>
            <p><strong>Tests Réussis:</strong> """ + str(report_data["summary"]["passed_tests"]) + """</p>
            <p><strong>Tests Échoués:</strong> """ + str(report_data["summary"]["failed_tests"]) + """</p>
        </div>
""")
            
            # Générer les sections pour chaque catégorie de test
            for category, tests in report_data["tests_results"].items():
                if not tests:
                    continue
                    
                f.write(f"""
        <div class="test-category">
            <h2>{category.replace('_', ' ').title()}</h2>
            <table>
                <tr>
                    <th>Test</th>
                    <th>Résultat</th>
                    <th>Détails</th>
                </tr>
""")
                
                for test in tests:
                    result_class = "test-passed" if test.get("passed", False) else "test-failed"
                    result_text = "Réussi" if test.get("passed", False) else "Échoué"
                    
                    f.write(f"""
                <tr class="{result_class}">
                    <td>{test.get('name', 'Test inconnu')}</td>
                    <td>{result_text}</td>
                    <td>{test.get('details', 'Aucun détail')}</td>
                </tr>
""")
                    
                f.write("""
            </table>
        </div>
""")
                
            # Fermer le HTML
            f.write("""
        <div class="footer">
            <p>GBPBot - Rapport de Tests de Pénétration Automatisés</p>
        </div>
    </div>
</body>
</html>
""")
            
        logger.info(f"Rapport HTML généré: {html_path}")
        return html_path
        
    except Exception as e:
        logger.error(f"Erreur lors de la génération du rapport HTML: {e}")
        return None

def copy_report_to_output(report_path, output_dir):
    """Copie le rapport JSON vers le répertoire de sortie"""
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    dest_path = output_dir / f"pentest_report_{timestamp}.json"
    
    try:
        shutil.copy2(report_path, dest_path)
        logger.info(f"Rapport copié vers: {dest_path}")
        return dest_path
    except Exception as e:
        logger.error(f"Erreur lors de la copie du rapport: {e}")
        return None

def analyze_report(report_path):
    """Analyse le rapport de test et affiche un résumé"""
    try:
        with open(report_path, 'r') as f:
            report = json.load(f)
        
        logger.info("=== Analyse du Rapport de Tests de Pénétration ===")
        logger.info(f"API Cible: {report['target_api']}")
        logger.info(f"Timestamp: {report['timestamp']}")
        
        # Résumé global
        total = report['summary']['total_tests']
        passed = report['summary']['passed_tests']
        failed = report['summary']['failed_tests']
        
        logger.info(f"Tests Totaux: {total}")
        logger.info(f"Tests Réussis: {passed}")
        logger.info(f"Tests Échoués: {failed}")
        
        if failed > 0:
            logger.warning("⚠️ Des vulnérabilités potentielles ont été détectées!")
            
            # Afficher les détails des tests échoués
            for category, tests in report['tests_results'].items():
                for test in tests:
                    if not test.get('passed', True):
                        logger.warning(f"❌ {category}: {test.get('name', 'Test inconnu')} - {test.get('details', 'Aucun détail')}")
        else:
            logger.info("✅ Aucune vulnérabilité détectée!")
        
        return report
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse du rapport: {e}")
        return None

def main():
    """Fonction principale"""
    args = parse_arguments()
    output_dir = setup_environment(args)
    
    # Configurer le niveau de log
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    logger.info("=== Démarrage des Tests de Pénétration Automatisés GBPBot ===")
    
    success = False
    if args.specific_test:
        success = run_specific_test(args.specific_test)
    else:
        success = run_all_tests()
    
    # Vérifier si le fichier de rapport a été généré
    report_path = Path("pentest_report.json")
    if report_path.exists():
        # Copier le rapport dans le répertoire de sortie
        json_path = copy_report_to_output(report_path, output_dir)
        
        # Analyser le rapport
        if json_path:
            analyze_report(json_path)
            
            # Générer un rapport HTML si demandé
            if args.html_report:
                html_path = generate_html_report(json_path, output_dir)
                if html_path:
                    logger.info(f"Rapport HTML disponible: {html_path}")
    else:
        logger.error("Aucun rapport généré. Les tests ont peut-être échoué.")
    
    logger.info("=== Tests de Pénétration Terminés ===")
    
    # Retourner un code de sortie en fonction du résultat
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main() 