# GBPBot - Trading Bot pour MEME coins

<div align="center">
    <img src="docs/images/logo.png" alt="GBPBot Logo" width="200" height="200" />
    <h3>Trading ultra-rapide et intelligent pour Solana, AVAX et Sonic</h3>
</div>

![License](https://img.shields.io/badge/license-MIT-blue)
![Python](https://img.shields.io/badge/python-3.11%2B-blue)
![Version](https://img.shields.io/badge/version-0.7.0-green)
![Security](https://img.shields.io/badge/security-codeql-green)
![Quality](https://img.shields.io/badge/quality-sonarqube-orange)
![AI](https://img.shields.io/badge/AI-Claude%203.7-purple)
![Stealth](https://img.shields.io/badge/stealth-advanced-black)

GBPBot est un bot de trading avanc√© con√ßu pour maximiser les profits dans l'√©cosyst√®me des MEME coins sur Solana, AVAX et Sonic. Il int√®gre des fonctionnalit√©s d'arbitrage, de sniping et de MEV/frontrunning avec une optimisation continue bas√©e sur l'intelligence artificielle avanc√©e via Claude 3.7.

## ‚ú® Caract√©ristiques principales

- **üöÄ Ultra-rapide** - Ex√©cution optimis√©e des transactions pour battre les autres bots
- **üõ°Ô∏è S√©curis√©** - Protection contre les rug pulls et les honeypots
- **ü§ñ Automatis√©** - Fonctionne en mode automatique ou semi-automatique
- **üìä Intelligent** - S'am√©liore automatiquement gr√¢ce √† l'analyse des donn√©es et au ML
- **üí∏ Rentable** - Maximise les profits via sniping, arbitrage et frontrunning
- **üîç Discret** - Syst√®me anti-d√©tection avanc√© avec simulation comportementale
- **üß† IA avanc√©e** - Analyses de march√© et strat√©gies optimis√©es par Claude 3.7
- **üîÑ Interface unifi√©e** - Acc√®s simplifi√© √† tous les modules via une interface centralis√©e

## üåü Modules principaux

1. **Arbitrage entre DEX**
   - Exploitation des √©carts de prix entre diff√©rents DEX/CEX
   - Ex√©cution instantan√©e des transactions pour profiter des opportunit√©s
   - Int√©gration d'un mode "Flash Arbitrage" pour ne jamais immobiliser de fonds
   - Optimisation des trades par IA avec Claude 3.7
   - ‚úÖ Module 100% finalis√© et optimis√©

2. **Sniping de Tokens**
   - Surveillance en temps r√©el des nouvelles paires cr√©√©es
   - D√©tection des whale movements pour identifier les tokens √† potentiel
   - Stop-loss intelligent et prise de profit automatique
   - Analyse de la liquidit√© et du market cap pour √©viter les scams
   - √âvaluation de risque avanc√©e via Claude 3.7
   - ‚úÖ Module 100% finalis√© et optimis√©

3. **MEV/Frontrunning pour AVAX**
   - Surveillance du mempool pour d√©tecter les opportunit√©s de frontrunning
   - Strat√©gies de frontrunning, backrunning et sandwich attacks
   - Optimisation des transactions pour maximiser les profits
   - Int√©gration avec Flashbots pour les bundles de transactions
   - Simulation des transactions avant ex√©cution
   - ‚è≥ Module √† 80% - Tests en environnement r√©el en cours

4. **Mode Automatique**
   - Analyse en temps r√©el des opportunit√©s sur plusieurs blockchains
   - Ajustement dynamique des strat√©gies en fonction des r√©sultats pass√©s
   - Gestion efficace des fonds bas√©e sur le risque/r√©compense
   - Strat√©gies de trading personnalis√©es g√©n√©r√©es par Claude 3.7
   - ‚úÖ Module 100% finalis√© et optimis√©

5. **Interface Unifi√©e (NOUVEAU)**
   - Point d'entr√©e unique pour tous les modules du bot
   - Architecture asynchrone compatible avec le reste du code
   - Mapping des modules et des modes d'ex√©cution pour un acc√®s simplifi√©
   - Gestion am√©lior√©e des configurations
   - ‚è≥ Module √† 85% - Finalisation de l'int√©gration avec tous les modules en cours

6. **Syst√®me Anti-D√©tection** 
   - Simulation comportementale multi-niveau (d√©butant, interm√©diaire, expert)
   - Rotation intelligente des wallets avec gestion de r√©putation
   - Randomisation des montants et timings de transactions
   - Pr√©vention des patterns r√©currents d√©tectables
   - Simulation de sessions de trading avec timing r√©aliste
   - ‚úÖ Int√©gr√© dans tous les modules

## üß† Intelligence artificielle int√©gr√©e 

GBPBot int√®gre Claude 3.7, l'un des mod√®les d'IA les plus avanc√©s, pour am√©liorer ses capacit√©s analytiques:

- **Analyse de march√© en temps r√©el** - Vue d'ensemble du march√© crypto avec tendances et opportunit√©s
- **√âvaluation avanc√©e des tokens** - Notation de risque, d√©tection des red flags et identification des gems
- **Strat√©gies de trading optimis√©es** - Points d'entr√©e/sortie et param√®tres personnalis√©s
- **Recherche web int√©gr√©e** - Enrichissement des analyses avec des donn√©es du web en temps r√©el

## ü§ñ Agent IA multi-modules

Le nouveau syst√®me d'Agent IA vous permet de:

- **Activer les capacit√©s d'IA** dans les modules d'arbitrage et de sniping existants
- **Choisir le niveau d'autonomie** adapt√© √† votre confort:
  - **Semi-autonome**: Validation humaine pour chaque action critique
  - **Autonome**: L'IA prend toutes les d√©cisions sans validation
  - **Hybride**: Validation uniquement pour les op√©rations √† risque √©lev√©
- **Utiliser le mode enti√®rement automatique** pour surveiller le march√© et ex√©cuter des strat√©gies intelligentes:
  - Analyse continue des opportunit√©s de trading
  - Prise de d√©cision bas√©e sur le contexte de march√©
  - Ex√©cution optimis√©e des transactions

L'Agent IA utilise LangChain pour orchestrer l'intelligence de Claude 3.7, am√©liorant consid√©rablement la d√©tection d'opportunit√©s et la prise de d√©cision.

[En savoir plus sur l'Agent IA](docs/AGENT_IA.md) | [En savoir plus sur l'int√©gration Claude 3.7](CLAUDE_INTEGRATION.md)

## üõ†Ô∏è Installation

### Pr√©requis

- Python 3.11 ou sup√©rieur
- Node.js et npm (pour l'adaptateur Solana Web3.js)
- Git
- Cl√© API Claude 3.7 (pour les fonctionnalit√©s d'IA avanc√©es)

### Installation automatique

Sous Linux/macOS:
```bash
git clone https://github.com/username/GBPBot.git
cd GBPBot
chmod +x install.sh
./install.sh
```

Sous Windows:
```bash
git clone https://github.com/username/GBPBot.git
cd GBPBot
install.bat
```

### Installation manuelle

1. Cloner le d√©p√¥t:
```bash
git clone https://github.com/username/GBPBot.git
cd GBPBot
```

2. Cr√©er et activer un environnement virtuel:
```bash
python -m venv venv
source venv/bin/activate  # Sur Windows: venv\Scripts\activate
```

3. Installer les d√©pendances:
```bash
pip install -r requirements.txt
```

4. Configurer les cl√©s API et les wallets:
```bash
cp .env.example .env
# Modifier le fichier .env avec vos cl√©s
```

## ‚öôÔ∏è Configuration

GBPBot est hautement configurable via le fichier `.env`. Voici les principaux param√®tres:

```env
# Configuration blockchain
SOLANA_RPC_URL=https://api.mainnet-beta.solana.com
SOLANA_PRIVATE_KEY=votre_cl√©_priv√©e_ici
AVAX_RPC_URL=https://api.avax.network/ext/bc/C/rpc
AVAX_PRIVATE_KEY=votre_cl√©_priv√©e_ici
SONIC_RPC_URL=https://rpc.sonic.fantom.network/
SONIC_PRIVATE_KEY=votre_cl√©_priv√©e_ici

# Configuration Claude 3.7
AI_PROVIDER=claude
CLAUDE_API_KEY=votre_cl√©_api_ici
CLAUDE_MODEL=claude-3-7-sonnet-20240229

# Param√®tres trading
MAX_SLIPPAGE=1.0
GAS_PRIORITY=medium
MAX_TRANSACTION_AMOUNT=0.1
ENABLE_SNIPING=true
ENABLE_ARBITRAGE=false
ENABLE_AUTO_MODE=false

# S√©curit√©
REQUIRE_CONTRACT_ANALYSIS=true
ENABLE_STOP_LOSS=true
DEFAULT_STOP_LOSS_PERCENTAGE=5
```

Consultez la [documentation compl√®te](docs/configuration.md) pour tous les param√®tres disponibles.

## üöÄ Utilisation

GBPBot peut √™tre utilis√© via son interface CLI conviviale ou sa nouvelle interface unifi√©e:

```bash
# D√©marrer le bot via l'interface CLI traditionnelle
python gbpbot_cli_bridge.py

# D√©marrer le bot via la nouvelle interface unifi√©e
python -m gbpbot.interface.unified_interface
```

### Interface CLI

L'interface CLI offre un menu interactif:

```
==========================================================
                GBPBot - Menu Principal
==========================================================
1. D√©marrer le Bot
2. Configurer les param√®tres
3. Afficher la configuration actuelle
4. Statistiques et Logs
5. Afficher les Modules Disponibles
6. Quitter
```

### Interface Unifi√©e (NOUVEAU)

La nouvelle interface unifi√©e permet d'acc√©der directement √† tous les modules:

```python
# Exemple d'utilisation programmatique
import asyncio
from gbpbot.interface.unified_interface import UnifiedInterface

async def main():
    ui = UnifiedInterface()
    await ui.initialize()
    
    # Lancer un module sp√©cifique
    await ui.launch_module("Arbitrage", mode="live")
    
    # Configurer les param√®tres
    await ui.configure()
    
    # Afficher les statistiques
    await ui.display_statistics()

if __name__ == "__main__":
    asyncio.run(main())
```

### Modes d'ex√©cution

Pour chaque module, vous pouvez choisir entre:

1. **Mode Test** - Simulation sans transactions r√©elles
2. **Mode Simulation** - Ex√©cution en environnement r√©el mais sans transactions financi√®res
3. **Mode Live** - Ex√©cution compl√®te avec transactions r√©elles

### Modules disponibles

S√©lectionnez un module apr√®s avoir d√©marr√© le bot:

```
==========================================================
               GBPBot - S√©lection de Module
==========================================================
1. Arbitrage entre les DEX
2. Sniping de Token
3. Mode Automatique
4. MEV/Frontrunning
5. AI Assistant
6. Backtesting
7. Retour au menu principal
```

Pour plus de d√©tails sur l'utilisation, consultez [le guide utilisateur complet](docs/USER_GUIDE.md).

## üìà Strat√©gies optimales

### Sniping de Tokens

- Prioriser Solana pour le sniping en raison des faibles frais et de la rapidit√©
- Cibler les tokens avec un ratio de liquidit√©/MarketCap > 5%
- Rechercher un volume potentiel de $500K+ en moins d'1h
- √âviter les tokens o√π le wallet du d√©veloppeur d√©tient >30% du supply

### Arbitrage

- Diviser les ordres en plusieurs petites transactions pour minimiser le slippage
- Utiliser l'optimisation du gaz pour d√©passer les autres traders
- Ex√©cuter des strat√©gies de "Flash Arbitrage" pour ne pas immobiliser de capital

## üìä Performance

GBPBot inclut un dashboard pour suivre les performances historiques et analyser les r√©sultats. Acc√©dez au dashboard via le menu principal ou directement via l'interface web:

```
http://localhost:8080
```

## üß™ Tests

Pour ex√©cuter les tests:

```bash
pytest -xvs tests/
```

## üîí S√©curit√© et Qualit√© du Code

GBPBot int√®gre des pratiques d'analyse de code automatis√©e pour garantir une qualit√© et une s√©curit√© optimales. Nous avons mis en place plusieurs outils pour analyser en continu la qualit√© et la s√©curit√© du code.

### Analyse Automatis√©e du Code

Nous utilisons les outils suivants pour maintenir la qualit√© et la s√©curit√© du code :

1. **CodeQL** - Analyse s√©mantique puissante pour d√©tecter les vuln√©rabilit√©s et les bugs
2. **SonarQube** - Analyse approfondie de la qualit√© et de la s√©curit√© du code
3. **Dependabot** - Surveillance automatique des d√©pendances pour d√©tecter les vuln√©rabilit√©s
4. **Bandit** - D√©tection des vuln√©rabilit√©s sp√©cifiques √† Python
5. **Safety** - V√©rification des d√©pendances Python pour les vuln√©rabilit√©s connues

### Analyse Locale

Pour les d√©veloppeurs souhaitant ex√©cuter des analyses localement avant de soumettre leur code, nous fournissons des scripts d'analyse locale :

- **Windows** : `analyse_locale.ps1`
- **Linux/macOS** : `analyse_locale.sh`

Ces scripts ex√©cutent les m√™mes analyses que notre pipeline CI/CD et g√©n√®rent des rapports d√©taill√©s dans le dossier `reports/`.

### Badges de Qualit√©

[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=GBPBot&metric=alert_status)](https://sonarcloud.io/dashboard?id=GBPBot)
[![Security Rating](https://sonarcloud.io/api/project_badges/measure?project=GBPBot&metric=security_rating)](https://sonarcloud.io/dashboard?id=GBPBot)
[![Maintainability Rating](https://sonarcloud.io/api/project_badges/measure?project=GBPBot&metric=sqale_rating)](https://sonarcloud.io/dashboard?id=GBPBot)

### Int√©gration CI/CD

Notre pipeline d'int√©gration continue v√©rifie automatiquement la qualit√© et la s√©curit√© du code √† chaque commit ou pull request :

- **Analyse statique** - D√©tection des bugs et des vuln√©rabilit√©s
- **Tests automatis√©s** - V√©rification de la fonctionnalit√© correcte
- **Couverture de code** - Suivi de la couverture des tests
- **V√©rification des d√©pendances** - D√©tection des versions obsol√®tes ou vuln√©rables

### Ex√©cuter l'Analyse Localement

Les d√©veloppeurs peuvent ex√©cuter les m√™mes analyses localement avant de soumettre leur code :

Sous Linux/macOS :
```bash
chmod +x analyse_locale.sh
./analyse_locale.sh
```

Sous Windows :
```bash
.\analyse_locale.ps1
```

Ces scripts ex√©cutent une suite d'analyses comprenant Bandit, Pylint, Safety, et Ruff, g√©n√©rant des rapports d√©taill√©s que vous pouvez consulter.

### R√©sultats de l'Analyse

Les r√©sultats des analyses sont disponibles :
- Dans les rapports g√©n√©r√©s localement
- Dans l'onglet "Security" du d√©p√¥t GitHub
- Dans le dashboard Codiga connect√© au projet
- Dans le dashboard SonarQube connect√© au projet

### Bonnes Pratiques de S√©curit√©

GBPBot impl√©mente les meilleures pratiques de s√©curit√© pour le trading de cryptomonnaies :
- D√©tection des secrets et des cl√©s priv√©es dans le code
- V√©rification des contrats avant interaction
- Protection contre les rug pulls et les honeypots
- Validation des transactions avant ex√©cution
- Gestion s√©curis√©e des cl√©s priv√©es

## üìù Licence

Ce projet est sous licence MIT. Voir le fichier [LICENSE](LICENSE) pour plus de d√©tails.

## ‚ö†Ô∏è Avertissement

Le trading de crypto-monnaies comporte des risques significatifs. N'investissez que ce que vous pouvez vous permettre de perdre. Les performances pass√©es ne garantissent pas les r√©sultats futurs.

## üîÑ Roadmap

- [x] Installation et configuration automatique
- [x] Module d'arbitrage entre DEX
- [x] Module de sniping de tokens
- [x] Mode automatique avec ML
- [x] M√©thodes de lancement unifi√©es
- [x] Int√©gration d'outils d'analyse de code et de s√©curit√©
- [ ] Interface web avanc√©e
- [ ] Support multicompte
- [ ] Int√©gration de nouveaux DEX (Raydium v2, Uniswap v4)
- [ ] Pr√©diction de tendances avec LLM
- [ ] Int√©gration avec Telegram

## ü§ù Contribuer

Les contributions sont les bienvenues! Consultez [CONTRIBUTING.md](CONTRIBUTING.md) pour les directives.

## üìß Contact

Pour toute question ou suggestion, n'h√©sitez pas √† ouvrir une issue sur ce d√©p√¥t.

## Syst√®me Anti-D√©tection

Le GBPBot int√®gre un syst√®me anti-d√©tection avanc√© qui lui permet de rester ind√©tectable par les DEX et autres acteurs de la blockchain. Ce syst√®me combine plusieurs couches de protection:

- **Rotation d'IP automatique** pour √©viter les bannissements
- **Randomisation des d√©lais** entre les transactions
- **Simulation comportementale humaine** pour √©viter les patterns d√©tectables
- **Transactions fant√¥mes** pour brouiller les pistes
- **Protection contre le blacklisting** des wallets 
- **Gestion intelligente des profils de trading** par IA pour √©quilibrer parfaitement discr√©tion et performance

### Gestion Automatique des Profils par IA

Le GBPBot dispose d√©sormais d'un syst√®me d'intelligence avanc√© qui permet aux diff√©rentes IA int√©gr√©es (Claude, OpenAI, LLaMA) de g√©rer automatiquement les profils de trading utilis√©s par le syst√®me anti-d√©tection:

- **Analyse contextuelle** de chaque op√©ration (blockchain, type d'op√©ration, token)
- **S√©lection optimale** du profil le plus adapt√© pour maximiser les profits tout en √©vitant la d√©tection
- **Adaptation dynamique** au niveau de risque de chaque blockchain
- **√âquilibre automatique** entre performance et discr√©tion selon vos priorit√©s
- **Tra√ßabilit√© des d√©cisions** pour comprendre le raisonnement de l'IA

Cette fonctionnalit√© permet au GBPBot de s'adapter automatiquement aux conditions du march√© et aux niveaux de risque, sans n√©cessiter d'intervention manuelle. La gestion des profils peut √™tre configur√©e pour privil√©gier la performance (profits maximaux) ou la discr√©tion (s√©curit√© maximale) selon vos pr√©f√©rences et les objectifs de trading.

## Configuration

Le GBPBot peut √™tre configur√© via le fichier `.env.local` √† la racine du projet. Voici les principales options:

```env
# Configuration g√©n√©rale
GBPBOT_LOG_LEVEL=INFO       # Niveau de log (DEBUG, INFO, WARNING, ERROR)

# Configuration blockchain
DEFAULT_BLOCKCHAIN=solana    # Blockchain par d√©faut (solana, avax, sonic)

# Configuration anti-d√©tection
ANTI_DETECTION_ENABLED=true  # Activer/d√©sactiver le syst√®me anti-d√©tection
AI_PROFILE_MANAGEMENT=true   # Gestion automatique des profils par IA
PERFORMANCE_PRIORITY=0.7     # √âquilibre performance/discr√©tion (0.0-1.0)

# Cl√©s API pour les IA (au moins une est n√©cessaire)
AI_PROVIDER=auto             # Provider √† utiliser: auto, claude, openai, llama
CLAUDE_API_KEY=your_api_key  # Cl√© API pour Claude d'Anthropic
CLAUDE_MODEL=claude-3-haiku-20240307  # Mod√®le Claude √† utiliser
OPENAI_API_KEY=your_api_key  # Cl√© API pour GPT d'OpenAI
OPENAI_MODEL=gpt-4           # Mod√®le OpenAI √† utiliser
LLAMA_MODEL_PATH=/path/to/model.gguf  # Chemin vers le mod√®le LLaMA
```

## Int√©gration d'un Agent IA Avanc√© dans GBPBot

Apr√®s analyse approfondie du code existant, je constate que votre GBPBot dispose d√©j√† de certaines bases pour l'int√©gration d'agents IA, notamment via:

1. Le syst√®me `profile_intelligence.py` qui permet une gestion intelligente des profils de trading par IA
2. L'int√©gration multi-mod√®les (Claude, OpenAI, LLaMA) avec la classe `LLMProvider`
3. Le `StealthManager` qui applique intelligemment des strat√©gies de trading

Cependant, votre proposition va plus loin en structurant un v√©ritable **agent autonome** avec orchestration d'outils et prise de d√©cision complexe. Voici une comparaison et mon analyse:

## Existant vs Proposition d'Agent IA

| Fonctionnalit√© | √âtat Actuel dans GBPBot | Proposition d'Agent IA |
|----------------|--------------------------|------------------------|
| Mod√®les IA | ‚úÖ Int√©gration multi-mod√®les (Claude, OpenAI, LLaMA) | ‚úÖ Similaire avec utilisation de LangChain |
| Orchestration | ‚ùå Pas d'orchestrateur central | ‚úÖ LangChain pour orchestrer les outils |
| Niveaux d'autonomie | ‚ö†Ô∏è Param√©trable mais non structur√© en "agents" | ‚úÖ Structure claire (semi-autonome, autonome, hybride) |
| Outils accessibles | ‚ö†Ô∏è Limit√©s aux modules internes | ‚úÖ Extension √† des APIs externes et web search |
| D√©cisions adaptatives | ‚ö†Ô∏è Bas√©es sur profils pr√©d√©finis | ‚úÖ Apprentissage continu et ajustement dynamique |

## Proposition d'Impl√©mentation d'Agent IA pour GBPBot

Pour impl√©menter cette architecture d'agent IA dans votre GBPBot, je vous recommande les √©tapes suivantes:

### 1. Cr√©ation du module `gbpbot/ai/agent_manager.py`

```python
"""
Module AgentManager - Syst√®me d'orchestration d'agents IA pour GBPBot

Ce module impl√©mente un agent IA avanc√© capable d'orchestrer l'ensemble des modules
du GBPBot pour une prise de d√©cision autonome ou semi-autonome bas√©e sur LangChain.
"""

import os
import json
import logging
import asyncio
from typing import Dict, List, Any, Optional, Union, Callable
from enum import Enum

# Importations LangChain
from langchain.agents import initialize_agent, Tool, AgentType
from langchain.llms.base import BaseLLM
from langchain.chains.conversation.memory import ConversationBufferMemory

# Importations internes
from gbpbot.utils.logger import setup_logger
from gbpbot.config.settings import get_settings
from gbpbot.ai.llm_provider import get_ai_client, LLMProvider, AiClientResponse
from gbpbot.ai.profile_intelligence import ProfileIntelligence
from gbpbot.security.stealth_manager import StealthManager
from gbpbot.modules.token_sniper import TokenSniper
from gbpbot.modules.arbitrage_engine import ArbitrageEngine
from gbpbot.modules.market_analyzer import MarketAnalyzer

# Configuration du logger
logger = setup_logger("agent_manager", logging.INFO)

class AgentAutonomyLevel(Enum):
    """Niveau d'autonomie de l'agent IA."""
    SEMI_AUTONOME = "semi_autonomous"  # Requiert validation humaine pour actions critiques
    AUTONOME = "autonomous"            # Totalement autonome
    HYBRIDE = "hybrid"                 # Adaptatif selon contexte et risque

class AgentManager:
    """
    Gestionnaire d'agents IA pour GBPBot.
    
    Impl√©mente un syst√®me avanc√© d'agents IA bas√©s sur LangChain pour
    orchestrer les diff√©rents modules du GBPBot et prendre des d√©cisions
    intelligentes de mani√®re autonome ou semi-autonome.
    """
    
    def __init__(
        self,
        autonomy_level: AgentAutonomyLevel = AgentAutonomyLevel.HYBRIDE,
        llm_provider: Optional[LLMProvider] = None,
        max_decision_amount: float = 0.1,  # Montant max pour d√©cisions sans validation
        require_approval_callback: Optional[Callable[[str, Dict[str, Any]], asyncio.Future]] = None
    ):
        """
        Initialise le gestionnaire d'agents IA.
        
        Args:
            autonomy_level: Niveau d'autonomie de l'agent
            llm_provider: Fournisseur de mod√®le LLM (Claude, OpenAI, LLaMA)
            max_decision_amount: Montant maximum pour d√©cisions autonomes
            require_approval_callback: Fonction de callback pour validation humaine
        """
        self.autonomy_level = autonomy_level
        self.llm_provider = llm_provider
        self.max_decision_amount = max_decision_amount
        self.require_approval_callback = require_approval_callback
        
        # √âtat interne
        self.initialized = False
        self.tools = []
        self.agent = None
        self.memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)
        
        # Composants du bot
        self.token_sniper = None
        self.arbitrage_engine = None
        self.market_analyzer = None
        self.stealth_manager = None
        self.profile_intelligence = None
        
        # Statistiques et m√©triques
        self.total_decisions = 0
        self.approved_decisions = 0
        self.rejected_decisions = 0
        self.autonomous_decisions = 0
        self.decision_history = []
        
        # Initialisation asynchrone
        asyncio.create_task(self._async_init())
    
    async def _async_init(self) -> None:
        """Initialisation asynchrone des composants."""
        try:
            # Initialiser le provider LLM si non fourni
            if not self.llm_provider:
                self.llm_provider = await get_ai_client()
                if not self.llm_provider:
                    logger.error("Impossible d'initialiser un provider LLM")
                    return
            
            # Initialiser les composants du bot
            # (Ces instanciations d√©pendraient de l'impl√©mentation r√©elle de vos modules)
            self.token_sniper = TokenSniper()
            self.arbitrage_engine = ArbitrageEngine()
            self.market_analyzer = MarketAnalyzer()
            self.stealth_manager = StealthManager()
            self.profile_intelligence = ProfileIntelligence()
            
            # D√©finir les outils disponibles pour l'agent
            self._define_tools()
            
            # Initialiser l'agent LangChain
            self._initialize_langchain_agent()
            
            self.initialized = True
            logger.info(f"Agent IA initialis√© avec niveau d'autonomie: {self.autonomy_level.value}")
        except Exception as e:
            logger.error(f"Erreur lors de l'initialisation de l'agent IA: {str(e)}")
    
    def _define_tools(self) -> None:
        """D√©finit les outils disponibles pour l'agent."""
        self.tools = [
            Tool(
                name="MarketAnalyzer",
                func=self._analyze_market,
                description="Analyse les donn√©es du march√© crypto et recommande des opportunit√©s."
            ),
            Tool(
                name="TokenSniper",
                func=self._snipe_token,
                description="Effectue un sniping rapide d'un token sp√©cifique."
            ),
            Tool(
                name="ArbitrageEngine",
                func=self._execute_arbitrage,
                description="Ex√©cute des op√©rations d'arbitrage entre DEX."
            ),
            Tool(
                name="ProfileManager",
                func=self._select_trading_profile,
                description="S√©lectionne le profil de trading optimal pour une op√©ration sp√©cifique."
            ),
            Tool(
                name="TransactionExecutor",
                func=self._execute_transaction,
                description="Ex√©cute une transaction blockchain avec les param√®tres sp√©cifi√©s."
            ),
            Tool(
                name="WebSearch",
                func=self._search_web,
                description="Recherche des informations sur le web pour enrichir l'analyse."
            )
        ]
    
    def _initialize_langchain_agent(self) -> None:
        """Initialise l'agent LangChain avec les outils d√©finis."""
        # Adapter le LLMProvider au format attendu par LangChain
        # (Ceci est une simplification, l'impl√©mentation r√©elle n√©cessiterait une adaptation plus pouss√©e)
        langchain_llm = self._adapt_llm_provider_to_langchain()
        
        if not langchain_llm:
            logger.error("Impossible d'adapter le LLMProvider pour LangChain")
            return
        
        # Initialiser l'agent
        self.agent = initialize_agent(
            tools=self.tools,
            llm=langchain_llm,
            agent=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,
            verbose=True,
            memory=self.memory
        )
    
    def _adapt_llm_provider_to_langchain(self) -> Optional[BaseLLM]:
        """
        Adapte le LLMProvider au format attendu par LangChain.
        
        Note: Cette m√©thode est une approximation simplifi√©e. L'impl√©mentation r√©elle
        n√©cessiterait une adaptation plus pouss√©e du LLMProvider √† l'interface BaseLLM de LangChain.
        
        Returns:
            Instance de BaseLLM compatible avec LangChain ou None si √©chec
        """
        # Impl√©mentation √† d√©velopper - ceci est un placeholder
        return None
    
    async def run_agent(self, query: str) -> Dict[str, Any]:
        """
        Ex√©cute l'agent IA avec une requ√™te sp√©cifique.
        
        Args:
            query: Requ√™te ou instruction pour l'agent
            
        Returns:
            R√©sultat de l'ex√©cution de l'agent
        """
        if not self.initialized or not self.agent:
            await self._async_init()
            if not self.initialized:
                return {"error": "Agent IA non initialis√©"}
        
        try:
            # Ex√©cuter l'agent
            result = await asyncio.to_thread(self.agent.run, query)
            
            # Mettre √† jour les statistiques
            self.total_decisions += 1
            
            return {
                "success": True,
                "result": result,
                "query": query
            }
        except Exception as e:
            logger.error(f"Erreur lors de l'ex√©cution de l'agent: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "query": query
            }
    
    # Impl√©mentations des fonctions d'outil (simplifi√©es pour l'exemple)
    
    async def _analyze_market(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Analyse le march√© et retourne des opportunit√©s."""
        # Impl√©mentation r√©elle utiliserait self.market_analyzer
        return {"status": "not_implemented"}
    
    async def _snipe_token(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Ex√©cute une op√©ration de sniping de token."""
        # V√©rifier si l'approbation est n√©cessaire
        if self._requires_approval(params):
            approved = await self._request_approval("Sniping de token", params)
            if not approved:
                return {"status": "rejected", "reason": "L'utilisateur a rejet√© l'op√©ration"}
        
        # Impl√©mentation r√©elle utiliserait self.token_sniper
        return {"status": "not_implemented"}
    
    async def _execute_arbitrage(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Ex√©cute une op√©ration d'arbitrage."""
        # Impl√©mentation similaire avec v√©rification d'approbation
        return {"status": "not_implemented"}
    
    async def _select_trading_profile(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """S√©lectionne le profil de trading optimal."""
        # Utiliserait self.profile_intelligence
        return {"status": "not_implemented"}
    
    async def _execute_transaction(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Ex√©cute une transaction blockchain."""
        # Impl√©mentation avec v√©rification d'approbation
        return {"status": "not_implemented"}
    
    async def _search_web(self, query: str) -> Dict[str, Any]:
        """Recherche des informations sur le web."""
        # Impl√©mentation d'un web scraper ou utilisation d'API
        return {"status": "not_implemented"}
    
    def _requires_approval(self, params: Dict[str, Any]) -> bool:
        """
        D√©termine si une op√©ration n√©cessite une approbation humaine.
        
        Args:
            params: Param√®tres de l'op√©ration
            
        Returns:
            True si l'approbation est n√©cessaire, False sinon
        """
        # Semi-autonome - toujours demander approbation
        if self.autonomy_level == AgentAutonomyLevel.SEMI_AUTONOME:
            return True
        
        # Autonome - jamais demander approbation
        if self.autonomy_level == AgentAutonomyLevel.AUTONOME:
            return False
        
        # Hybride - d√©cider en fonction des param√®tres
        # Par exemple, v√©rifier si le montant d√©passe le seuil
        amount = params.get("amount", 0.0)
        if amount > self.max_decision_amount:
            return True
        
        # V√©rifier si l'op√©ration est √† haut risque
        risk_level = params.get("risk_level", "low")
        if risk_level.lower() in ["high", "tr√®s √©lev√©", "extreme"]:
            return True
        
        return False
    
    async def _request_approval(self, operation: str, params: Dict[str, Any]) -> bool:
        """
        Demande l'approbation utilisateur pour une op√©ration.
        
        Args:
            operation: Description de l'op√©ration
            params: Param√®tres de l'op√©ration
            
        Returns:
            True si approuv√©, False sinon
        """
        if not self.require_approval_callback:
            logger.warning("Callback d'approbation non configur√©, refus automatique")
            return False
        
        try:
            # Cr√©er un future pour attendre la r√©ponse
            approval_future = self.require_approval_callback(operation, params)
            
            # Attendre la r√©ponse avec timeout
            approved = await asyncio.wait_for(approval_future, timeout=300)  # 5 minutes max
            
            # Mettre √† jour les statistiques
            if approved:
                self.approved_decisions += 1
            else:
                self.rejected_decisions += 1
            
            return approved
        except asyncio.TimeoutError:
            logger.warning(f"Timeout de l'approbation pour {operation}, refus automatique")
            self.rejected_decisions += 1
            return False
        except Exception as e:
            logger.error(f"Erreur lors de la demande d'approbation: {str(e)}")
            self.rejected_decisions += 1
            return False
    
    def get_stats(self) -> Dict[str, Any]:
        """
        Retourne les statistiques de l'agent.
        
        Returns:
            Dictionnaire de statistiques
        """
        return {
            "total_decisions": self.total_decisions,
            "approved_decisions": self.approved_decisions,
            "rejected_decisions": self.rejected_decisions,
            "autonomous_decisions": self.autonomous_decisions,
            "approval_rate": self.approved_decisions / max(1, self.total_decisions),
            "autonomy_level": self.autonomy_level.value,
            "initialized": self.initialized
        }

def create_agent_manager(
    autonomy_level: str = "hybrid",
    max_decision_amount: float = 0.1,
    require_approval_callback: Optional[Callable] = None
) -> AgentManager:
    """
    Cr√©e et retourne une instance d'AgentManager.
    
    Args:
        autonomy_level: Niveau d'autonomie ("semi_autonomous", "autonomous", "hybrid")
        max_decision_amount: Montant maximum pour d√©cisions autonomes
        require_approval_callback: Fonction de callback pour validation humaine
        
    Returns:
        Instance d'AgentManager
    """
    # Convertir la cha√Æne en enum
    autonomy_enum = AgentAutonomyLevel.HYBRIDE
    if autonomy_level == "semi_autonomous":
        autonomy_enum = AgentAutonomyLevel.SEMI_AUTONOME
    elif autonomy_level == "autonomous":
        autonomy_enum = AgentAutonomyLevel.AUTONOME
    
    return AgentManager(
        autonomy_level=autonomy_enum,
        max_decision_amount=max_decision_amount,
        require_approval_callback=require_approval_callback
    )
```

### 2. Int√©gration dans le syst√®me existant (`gbpbot/main.py` ou √©quivalent)

```python
# Ajouter √† votre fichier principal

from gbpbot.ai.agent_manager import create_agent_manager

# Callback pour demander l'approbation utilisateur
async def request_user_approval(operation: str, params: Dict[str, Any]) -> bool:
    # En mode CLI
    print(f"\n[APPROBATION REQUISE] {operation}")
    print("Param√®tres:", json.dumps(params, indent=2))
    response = input("Approuver (o/n)? ").lower()
    return response in ["o", "oui", "y", "yes"]

# Cr√©ation de l'agent avec callback d'approbation
agent_manager = create_agent_manager(
    autonomy_level="hybrid",  # "semi_autonomous", "autonomous" ou "hybrid"
    max_decision_amount=0.1,  # 0.1 ETH/SOL/etc. maximum sans approbation
    require_approval_callback=request_user_approval
)

# Exemple d'utilisation dans un menu
async def menu_agent_ia():
    print("\n=== Menu Agent IA ===")
    print("1. Analyse du march√© et recommandation")
    print("2. Recherche d'opportunit√©s d'arbitrage")
    print("3. D√©tection et sniping de nouveaux tokens")
    print("4. Mode autonome (24h)")
    print("5. Retour")
    
    choice = input("Votre choix: ")
    
    if choice == "1":
        result = await agent_manager.run_agent("Analyse le march√© crypto actuel et recommande les 3 meilleures opportunit√©s de trading.")
        print(result.get("result", "Erreur lors de l'analyse"))
    elif choice == "2":
        result = await agent_manager.run_agent("Trouve les meilleures opportunit√©s d'arbitrage entre DEX sur Solana avec au moins 2% de profit potentiel.")
        print(result.get("result", "Erreur lors de la recherche d'arbitrage"))
    elif choice == "3":
        result = await agent_manager.run_agent("D√©tecte et analyse les nouveaux tokens sur Solana ayant une liquidit√© d'au moins 10K$, et pr√©pare une strat√©gie de sniping optimale.")
        print(result.get("result", "Erreur lors de la d√©tection"))
    elif choice == "4":
        # Lancer l'agent en mode autonome (exemple simplifi√©)
        print("Mode autonome activ√© pour 24h. Utiliser Ctrl+C pour arr√™ter.")
        try:
            while True:
                await agent_manager.run_agent("Surveille le march√© et ex√©cute automatiquement les meilleures opportunit√©s de profit.")
                await asyncio.sleep(300)  # 5 minutes entre chaque cycle
        except KeyboardInterrupt:
            print("Mode autonome arr√™t√© par l'utilisateur")
```

### 3. Installation des d√©pendances

Cr√©ez un fichier `requirements-agent.txt` avec:

```
langchain>=0.0.300
openai>=0.27.0
anthropic>=0.5.0
llama-cpp-python>=0.1.50  # Si utilisation locale de LLaMA
duckduckgo-search>=1.0.0  # Pour recherche web
```

Puis ex√©cutez:

```bash
pip install -r requirements-agent.txt
```

## Avantages par rapport √† l'impl√©mentation actuelle

1. **Architecture d'agent formalis√©e** - Syst√®me complet d'agents au lieu de simples int√©grations IA ponctuelles
2. **Orchestration LangChain** - Utilisation d'un framework optimis√© pour les agents IA
3. **Niveaux d'autonomie structur√©s** - Syst√®me clairement d√©fini allant de semi-autonome √† autonome adaptatif
4. **Int√©gration d'outils externes** - Possibilit√© d'exploiter des APIs et informations web
5. **M√©canisme d'approbation** - Syst√®me de validation pour les d√©cisions critiques
6. **Suivi statistique avanc√©** - Analyse des performances de l'agent

## Prochaines √©tapes recommand√©es

1. **Impl√©mentation de l'AgentManager** - Cr√©er les fichiers et modules n√©cessaires
2. **Adaptation LLMProvider pour LangChain** - Cr√©er une couche d'adaptation entre votre syst√®me et LangChain
3. **D√©veloppement des outils sp√©cifiques** - Impl√©menter les fonctions d'outils qui utilisent vos modules existants
4. **Tests en environnement contr√¥l√©** - D√©marrer avec des montants faibles et validation humaine requise
5. **Documentation utilisateur** - Guide explicatif sur le fonctionnement et la configuration de l'agent

Souhaitez-vous que j'approfondisse un aspect sp√©cifique de cette proposition d'impl√©mentation?

## üß™ Tests de S√©curit√©

GBPBot int√®gre plusieurs m√©canismes pour garantir la s√©curit√© du syst√®me :

- **Analyse statique du code** avec CodeQL et SonarCloud
- **V√©rification des d√©pendances** pour les vuln√©rabilit√©s connues
- **Tests de p√©n√©tration automatis√©s** pour d√©tecter les faiblesses potentielles
- **Protection contre les attaques** (injections, XSS, etc.)
- **Audit r√©gulier** du code et des processus

## üìö Documentation

GBPBot dispose d'une documentation compl√®te pour vous aider :

- [Guide d'Utilisation](gbpbot/USER_GUIDE.md) - Guide complet pour l'utilisation du bot
- [Documentation Technique](gbpbot/TECHNICAL_DOCUMENTATION.md) - Architecture et d√©tails techniques
- [Guide des Tests de P√©n√©tration](docs/PENTESTS_GUIDE.md) - Comment tester la s√©curit√© du bot
- [Guide d'API](docs/API_REFERENCE.md) - Documentation de l'API (si applicable)

Pour plus de documentation, consultez le r√©pertoire [docs/](docs/).